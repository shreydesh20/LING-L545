# -*- coding: utf-8 -*-
"""NLP Final Project

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qxHAZ2HhZCDDsRAqACl8rcoCA67zZBqE

Computational Linguistics: Final Project

**Natural Language to Cypher Query Translation**

Shreyasi Deshmukh
"""

pip install neo4j

#Required Python Libraries for Neo4j 
from neo4j import GraphDatabase
import logging
from neo4j.exceptions import ServiceUnavailable

#Required Python Libraries -NLTK, Spacy, Neo4j 
import nltk 
from nltk.corpus import wordnet 
nltk.download('wordnet')
nltk.download('omw-1.4')
import spacy 
nlp = spacy.load("en_core_web_sm")

#Contains Synonyms for the Words:
#1. MATCH
#2. CREATE
#3. DELETE

class Query_Type:
  def __init__(self):
    self.match_query()
    self.match_syn=None
    self.create_query()
    self.create_syn=None
    self.delete_query()
    self.delete_syn=None
    
    pass
  def match_query():
    match_syn =[]
    for syn in wordnet.synsets('Find'):
      for lemma in syn.lemmas():
        match_syn.append(lemma.name())
    return match_syn
    self.match_syn=match_syn

  def create_query():
    create_syn =[]
    for syn in wordnet.synsets('Create'):
      for lemma in syn.lemmas():
        create_syn.append(lemma.name())
    return create_syn
    self.create_syn=create_syn

  def delete_query():
    delete_syn =[]
    for syn in wordnet.synsets('Delete'):
      for lemma in syn.lemmas():
        delete_syn.append(lemma.name())
    return delete_syn
    self.delete_syn=delete_syn

#Function will convert the input command get the Part of Speech of every word. Returns the ROOT, which indicates the command required. 
def get_tokens(doc):
  doc=nlp(doc)
  plist=[]
  output=""
  for tok in doc:
    output=(tok.text, tok.dep_)
    plist.append(output)
  for (x, y) in plist:
    if y == 'ROOT':
      return x

#Function determines the kind of query to be used based on the ROOT of the input command 
def get_query_type(doc):
  match_syn= Query_Type.match_query()
  delete_syn= Query_Type.delete_query()
  create_syn= Query_Type.create_query()
  root_word= get_tokens(doc)
  root_word= root_word.lower()
  query= 0 
  if root_word in match_syn:
    print("Query Type is Match")
    query = 1
  elif root_word in create_syn:
    print('"Query Type is Create')
    query = 2
  elif root_word in delete_syn:
    print('"Query Type is Delete')
    query = 3
  else:
    print("Command not found. Please try again")
  return query

#Referred to the following video while creating this function: 
#https://www.youtube.com/watch?v=2XUhKpH0p4M

def get_name(doc):
  doc=nlp(doc)
  for ent in doc.ents:
    #print(ent.text, "|", ent.label_)
    return ent.text, ent.label_

class Get_Queries:


  def __init__(self) -> None:
    self.match_query= None
    self.create_query= None 
    self.delete_query= None
    self.match_m()
    self.match_p()
    self.create_mcypher()
    self.create_pcypher()
    self.delete_mcypher()
    self.delete_pcypher()

  def match_p(n):
    string1= "MATCH (a: Person {name:'"
    string2= "'}) RETURN a"
    match_query  = string1 + n + string2
    return match_query 
    self.match_query = match_query 

  def match_m(n):
    string1= "MATCH (a: Movie {title:'"
    string2= "'}) RETURN a"
    match_query  = string1 + n + string2
    return match_query 
    self.match_query = match_query 

  
  def delete_pcypher(n):
    string1= "MATCH (a: Person {name:'"
    string2 = "'}) DETACH DELETE a"
    delete_person= string1 + n + string2
    return delete_person
    self.delete_person = delete_person


  def delete_mcypher(n):
    string1= "MATCH (a: Movie {title:'"
    string2 = "'}) DETACH DELETE a"
    delete_movie= string1 + n + string2
    return delete_movie
    self.delete_movie = delete_movie  
    

  def create_pcypher(n):
    string1= "CREATE (a: Person {name:'"
    string2 = "'}) RETURN a"
    create_person = string1 + n + string2
    return create_person 
    self.create_person  =create_person 

  def create_mcypher(n):
    string1= "CREATE (a: Movie {title:'"
    string2 = "'}) RETURN a"
    create_movie = string1 + n + string2
    return create_movie 
    self.create_movie  =create_movie

#Below is the Python API provided by Neo4j Aura. Password has been changed to default for privacy
#Code referred and from https://console.neo4j.io/?language=Python&product=aura-db#how-to-connect 

class App:

    def __init__(self, uri, user, password):
        self.driver = GraphDatabase.driver(uri, auth=(user, password))

    def close(self):
        # Don't forget to close the driver connection when you are finished with it
        self.driver.close()

    def create_friendship(self, person1_name, person2_name):
        with self.driver.session(database="neo4j") as session:
            # Write transactions allow the driver to handle retries and transient errors
            result = session.execute_write(
                self._create_and_return_friendship, person1_name, person2_name)
            for row in result:
                print("Created friendship between: {p1}, {p2}".format(p1=row['p1'], p2=row['p2']))

    
    def _create_and_return_friendship(tx, person1_name, person2_name):
        # To learn more about the Cypher syntax, see https://neo4j.com/docs/cypher-manual/current/
        # The Reference Card is also a good resource for keywords https://neo4j.com/docs/cypher-refcard/current/
        query = (
            "CREATE (p1:Person { name: $person1_name }) "
            "CREATE (p2:Person { name: $person2_name }) "
            "CREATE (p1)-[:KNOWS]->(p2) "
            "RETURN p1, p2"
        )
        result = tx.run(query, person1_name=person1_name, person2_name=person2_name)
        try:
            return [{"p1": row["p1"]["name"], "p2": row["p2"]["name"]}
                    for row in result]
        # Capture any errors along with the query and data for traceability
        except ServiceUnavailable as exception:
            logging.error("{query} raised an error: \n {exception}".format(
                query=query, exception=exception))
            raise

    def create_actor(self, person1_name):
        with self.driver.session(database="neo4j") as session:
            # Write transactions allow the driver to handle retries and transient errors
            result = session.execute_write(
                self._create_actor, person1_name)
            for row in result:
                print("Created actor: {p1}".format(p1=row['p1']))


    @staticmethod
    def _create_actor(tx, person1_name):
        # To learn more about the Cypher syntax, see https://neo4j.com/docs/cypher-manual/current/
        # The Reference Card is also a good resource for keywords https://neo4j.com/docs/cypher-refcard/current/
        query = (
            "CREATE (p1:Person { name: $person1_name }) "
            "RETURN p1"
        )
        result = tx.run(query, person1_name=person1_name)
        try:
            return [{"p1": row["p1"]["name"]}
                    for row in result]
        # Capture any errors along with the query and data for traceability
        except ServiceUnavailable as exception:
            logging.error("{query} raised an error: \n {exception}".format(
                query=query, exception=exception))
            raise

    

    def find_person(self, person_name):
        with self.driver.session(database="neo4j") as session:
            result = session.execute_read(self._find_and_return_person, person_name)
            print(result)
            for row in result:
                print("Found person: {row}".format(row=row))

    @staticmethod
    def _find_and_return_person(tx, person_name):
        query = (
            "MATCH (p:Person) "
            "WHERE p.name = $person_name "
            "RETURN p.name AS name"
        )
        result = tx.run(query, person_name=person_name)
        print(result)
        return [row["name"] for row in result]

    def find_movie(self, movie_name):
        with self.driver.session(database="neo4j") as session:
            result = session.execute_read(self._find_and_return_movie, movie_name)
            print(result)
            for row in result:
                print("Found Movie: {row}".format(row=row))

    @staticmethod
    def _find_and_return_movie(tx, movie_name):
        query = (
            "MATCH (m:Movie) "
            "WHERE m.name = $movie_name "
            "RETURN m.name AS name"
        )
        result = tx.run(query, movie_name=movie_name)
        print(result)
        return [row["name"] for row in result]

if __name__ == "__main__":
    # Aura queries use an encrypted connection using the "neo4j+s" URI scheme
    uri = "neo4j+s://b91d9d7b.databases.neo4j.io"
    user = "neo4j"
    password = "password"
    app = App(uri, user, password)
    _query_= Get_Queries
    sentence = input("Please enter command to be converted into Cypher Query ")
    name, label=get_name(sentence)
    print("Name: ", name,"Label:", label)
    query=  get_query_type(sentence)
    if query== 1:
      if label == "PERSON":
        app.find_person(name)
        print(_query_.match_p(name))
      else:
        app.find_movie(name)
        print(_query_.match_m(name))
    if query == 2:
      if label == "PERSON":
        print(_query_.create_pcypher(name))
      else:
        print(_query_.create_mcypher(name))
    if query == 3:
      if label == "PERSON":
        print(_query_.delete_pcypher(name))
      else:
        print(_query_.delete_mcypher(name))
    

   
  


    
    app.close()



